/*
 * generated by Xtext
 */
package de.unistuttgart.iste.ps.skilled.formatting2;

import com.google.inject.Inject
import de.unistuttgart.iste.ps.skilled.sKilL.Arraytype
import de.unistuttgart.iste.ps.skilled.sKilL.Basetype
import de.unistuttgart.iste.ps.skilled.sKilL.Constant
import de.unistuttgart.iste.ps.skilled.sKilL.Data
import de.unistuttgart.iste.ps.skilled.sKilL.Declaration
import de.unistuttgart.iste.ps.skilled.sKilL.Enumtype
import de.unistuttgart.iste.ps.skilled.sKilL.Field
import de.unistuttgart.iste.ps.skilled.sKilL.File
import de.unistuttgart.iste.ps.skilled.sKilL.Hint
import de.unistuttgart.iste.ps.skilled.sKilL.HintArgument
import de.unistuttgart.iste.ps.skilled.sKilL.Include
import de.unistuttgart.iste.ps.skilled.sKilL.IncludeFile
import de.unistuttgart.iste.ps.skilled.sKilL.Interfacetype
import de.unistuttgart.iste.ps.skilled.sKilL.Listtype
import de.unistuttgart.iste.ps.skilled.sKilL.Maptype
import de.unistuttgart.iste.ps.skilled.sKilL.Restriction
import de.unistuttgart.iste.ps.skilled.sKilL.RestrictionArgument
import de.unistuttgart.iste.ps.skilled.sKilL.Settype
import de.unistuttgart.iste.ps.skilled.sKilL.TypeDeclaration
import de.unistuttgart.iste.ps.skilled.sKilL.TypeDeclarationReference
import de.unistuttgart.iste.ps.skilled.sKilL.Typedef
import de.unistuttgart.iste.ps.skilled.sKilL.Usertype
import de.unistuttgart.iste.ps.skilled.sKilL.View
import de.unistuttgart.iste.ps.skilled.services.SKilLGrammarAccess
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion

/**
 * Formatting for SKilL 
 * The Formatting2 API from Xtext is still provisional, hence the many warnings from eclipse.
 * 
 * @author Marco Link 
 */
@SuppressWarnings("all")
class SKilLFormatter extends AbstractFormatter2 {

  @Inject extension SKilLGrammarAccess

  def dispatch void format(File file, extension IFormattableDocument document) {

    // Formats the headcomments - default newline 1 but also possible 2 or 3 if the user wants it.
    for (ISemanticRegion headComment : file.regionFor.ruleCallsTo(HEADCOMMENTRule)) {
      headComment.prepend[priority = -1; noSpace]
      headComment.append[setNewLines(1, 1, 3)];
    }

    // The last headcomment gets 2 newlines
    file.regionFor.ruleCallsTo(HEADCOMMENTRule).last.append[priority = 1; newLines = 2];

    // Formats the includes
    for (Include includes : file.getIncludes()) {
      format(includes, document);
    }

    // The last include gets 2 newlines.
    file.includes.last.append[priority = 1; newLines = 2];

    // Formats the declarations
    for (Declaration declarations : file.getDeclarations()) {
      format(declarations, document);
    }
  }

  def dispatch void format(Include include, extension IFormattableDocument document) {

    // Before the keywords should be no space.
    include.regionFor.keyword('include').prepend[priority = -1; noSpace];
    include.regionFor.keyword('with').prepend[priority = -1; noSpace];

    // Formats the actually included skill files and they should be sourrounded by one space.
    for (IncludeFile includeFiles : include.getIncludeFiles()) {
      includeFiles.surround[oneSpace];
    }

    // After each include they should be at least be 1 newline, but 2 or 3 are also allowed.
    include.append[setNewLines(1, 1, 3)];
  }

  def void formatDeclaration(Declaration declaration, extension IFormattableDocument document) {

    declaration.prepend[priority = 1; noSpace];

    // The name should be surrounded by one space
    declaration.regionFor.ruleCallTo(IDRule).surround[priority = -1; oneSpace];

    // The Comment should be followed by one newline.
    declaration.regionFor.ruleCallTo(ML_COMMENTRule).append[newLine];
  }

  def void formatTypeDeclaration(TypeDeclaration typeDeclaration, extension IFormattableDocument document) {
    formatDeclaration(typeDeclaration, document);

    for (TypeDeclarationReference supertypes : typeDeclaration.getSupertypes()) {
      format(supertypes, document);
    }

    for (Field fields : typeDeclaration.getFields()) {
      format(fields, document);
    }

    // Format the braces and increase the indentation between them.
    if (typeDeclaration.fields.size > 0) {
      val open = typeDeclaration.regionFor.keyword("{")
      val close = typeDeclaration.regionFor.keyword("}")
      interior(open, close)[indent]
      open.prepend[oneSpace].append [
        priority = -1;
        setNewLines(1, 1, 2);
      ];
      close.prepend[priority = 1; newLines = 1].append [
        newLines = 2
      ];
    } // If there are no fields, the curly braces will be in one line.
    else {
      typeDeclaration.regionFor.keyword("{").prepend[oneSpace].append[noSpace];
      typeDeclaration.regionFor.keyword("}").prepend[noSpace].append[newLines = 2];
    }

    for (ISemanticRegion isr : typeDeclaration.regionFor.keywords(":", "extends", "with")) {
      isr.surround[oneSpace];
    }
  }

  def dispatch void format(Typedef typedef, extension IFormattableDocument document) {
    formatDeclaration(typedef, document);
    // The restrictions and hints should be indented.
    val open = typedef.regionFor.ruleCallTo(IDRule);
    val close = typedef.regionFor.keyword(";");
    interior(open, close)[indent]

    for (Restriction restrictions : typedef.getRestrictions()) {
      format(restrictions, document);
    }

    for (Hint hints : typedef.getHints()) {
      format(hints, document);
    }

    format(typedef.getFieldtype(), document);
    typedef.regionFor.keyword(";").prepend[priority = 2; noSpace].append[newLines = 2];
  }

  def dispatch void format(Enumtype enumtype, extension IFormattableDocument document) {
    formatDeclaration(enumtype, document);
    for (Field fields : enumtype.getFields()) {
      format(fields, document);
    }
    val open = enumtype.regionFor.keyword("{")
    val close = enumtype.regionFor.keyword("}")
    interior(open, close)[indent]
    if ((enumtype.fields.size > 0) || (enumtype.instances.size > 0)) {
      open.prepend[oneSpace].append[setNewLines(1, 1, 2)];
      close.prepend[priority = 1; newLines = 1].append [
        newLines = 2
      ];
    } else {
      enumtype.regionFor.keyword("{").prepend[oneSpace].append[noSpace];
      enumtype.regionFor.keyword("}").prepend[noSpace].append[newLines = 2];
    }

    for (ISemanticRegion comma : enumtype.regionFor.keywords(",")) {
      comma.prepend[noSpace];
      comma.append[oneSpace];
    }

    enumtype.regionFor.keyword(";").prepend[noSpace].append[newLines = 2]
  }

  def dispatch void format(Interfacetype interfacetype, extension IFormattableDocument document) {
    formatTypeDeclaration(interfacetype, document);
  }

  def dispatch void format(Usertype usertype, extension IFormattableDocument document) {
    formatTypeDeclaration(usertype, document);

    for (Restriction restrictions : usertype.getRestrictions()) {
      format(restrictions, document);
    }

    for (Hint hints : usertype.getHints()) {
      format(hints, document);
    }
  }

  def dispatch void format(Field field, extension IFormattableDocument document) {
    field.prepend[noSpace];
    field.regionFor.ruleCallTo(ML_COMMENTRule).prepend[priority = 2; newLines = 2].append[newLine];

    for (Restriction restrictions : field.getRestrictions()) {
      format(restrictions, document);
    }

    for (Hint hints : field.getHints()) {
      format(hints, document);
    }

    format(field.getFieldcontent(), document);

    if ((field.hints.size() == 0) && (field.restrictions.size() == 0)) {
      field.regionFor.keyword(";").append[setNewLines(1, 1, 2)];
    } else {
      // If there are restrictions or hints, there should be a newline before and also after it there should be 2 newlines.
      field.prepend[priority = 1; newLines = 2];
      field.regionFor.keyword(";").append[newLines = 2];
    }
  }

  def dispatch void format(Restriction restriction, extension IFormattableDocument document) {
    restriction.regionFor.keyword("@").surround[noSpace];

    for (RestrictionArgument restrictionArguments : restriction.getRestrictionArguments()) {
      format(restrictionArguments, document);
    }

    restriction.regionFor.keyword("(").surround[noSpace];
    restriction.regionFor.keyword(")").surround[noSpace];
    restriction.regionFor.keyword(",").prepend[noSpace].append[oneSpace];
    restriction.append[newLine];
  }

  def dispatch void format(Hint hint, extension IFormattableDocument document) {
    hint.regionFor.keyword("!").surround[noSpace];

    for (HintArgument hintArguments : hint.getHintArguments()) {
      format(hintArguments, document);
    }

    if (hint.hintName.equals("pragma")) {
      hint.hintArguments.get(0).surround[priority = 1; oneSpace]
    }

    hint.regionFor.keyword("(").surround[noSpace];
    hint.regionFor.keyword(")").surround[noSpace];
    hint.regionFor.keyword(",").prepend[noSpace].append[oneSpace];
    hint.append[newLine];
  }

  def dispatch void format(View view, extension IFormattableDocument document) {
    view.surround[noSpace];
    view.regionFor.keyword("view").append[oneSpace];
    view.regionFor.keyword("as").surround[oneSpace];
    format(view.fieldcontent, document);
    format(view.fieldtype, document);
    // The name of the view
    view.regionFor.ruleCallTo(XIDRule).prepend[oneSpace].append[noSpace];
  }

  def dispatch void format(Constant constant, extension IFormattableDocument document) {
    constant.surround[noSpace];
    constant.regionFor.keyword("const").append[oneSpace];
    // The name of the constant
    constant.regionFor.ruleCallTo(XIDRule).prepend[oneSpace];
    constant.regionFor.keyword("=").surround[oneSpace];
    format(constant.getFieldtype(), document);
  }

  def dispatch void format(Data data, extension IFormattableDocument document) {
    data.surround[noSpace];
    data.regionFor.keyword("auto").append[oneSpace];
    // The name of the data
    data.regionFor.ruleCallTo(XIDRule).prepend[oneSpace].append[noSpace];
    format(data.getFieldtype(), document);
  }

  def dispatch void format(Maptype maptype, extension IFormattableDocument document) {
    maptype.regionFor.keyword("<").surround[noSpace];
    maptype.regionFor.keyword(">").prepend[priority = 2; noSpace].append[oneSpace];
    maptype.regionFor.keyword(",").prepend[noSpace].append[oneSpace];
    for (Basetype basetypes : maptype.getBasetypes()) {
      format(basetypes, document);
    }
  }

  def dispatch void format(Settype settype, extension IFormattableDocument document) {
    settype.regionFor.keyword("<").surround[noSpace];
    settype.regionFor.keyword(">").prepend[priority = 2; noSpace].append[oneSpace];
    format(settype.getBasetype(), document);
  }

  def dispatch void format(Listtype listtype, extension IFormattableDocument document) {
    listtype.regionFor.keyword("<").surround[noSpace];
    listtype.regionFor.keyword(">").prepend[priority = 2; noSpace].append[oneSpace];
    format(listtype.getBasetype(), document);
  }

  def dispatch void format(Arraytype arraytype, extension IFormattableDocument document) {
    arraytype.regionFor.keyword("[").surround[noSpace];
    arraytype.regionFor.keyword("]").prepend[priority = 2; noSpace].append[oneSpace];
    format(arraytype.getBasetype(), document);
  }

  def dispatch void format(Basetype basetype, extension IFormattableDocument document) {
    basetype.append[priority = 1; oneSpace];
  }
}
