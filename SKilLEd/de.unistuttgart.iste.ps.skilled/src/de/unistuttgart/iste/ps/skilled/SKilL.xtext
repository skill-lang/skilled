/** 
 * Xtext grammar for SKilL
 * TODO: Views
 * 
 * @author Marco Link and Nikolay Fateev
 */
grammar de.unistuttgart.iste.ps.skilled.SKilL hidden(WHITESPACE)

generate sKilL "http://www.unistuttgart.de/iste/ps/skilled/SKilL"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

File:
	(headComments+=HEADCOMMENT)* (includes+=Include)* (declarations+=Declaration)*;

Include:
	('include' | 'with') (includeFiles+=IncludeFile)+;

IncludeFile:
	importURI=STRING;

Declaration:
	Typedef | Enumtype | TypeDeclaration;

/* A "Goto" link */
DeclarationReference:
	type=[Declaration];

	// Restricts that only interfaces and usertypes can be supertypes.
TypeDeclaration:
	Interfacetype | Usertype;

	// This indirection is needed for semantic syntax coloring.
TypeDeclarationReference:
	type=[TypeDeclaration];

Typedef:
	comment=ML_COMMENT? 'typedef' name=ID
	(restrictions+=Restriction | hints+=Hint)* fieldtype=Fieldtype ';';

Enumtype:
	comment=ML_COMMENT?
	'enum' name=ID '{' instances+=ID (',' instances+=ID)* ';' (fields+=Field)* '}';

Interfacetype:
	comment=ML_COMMENT?
	'interface' name=ID ((':' | 'with' | 'extends') (supertypes+=TypeDeclarationReference))*
	('{' (fields+=Field)* '}')?;

Usertype:
	comment=ML_COMMENT? (restrictions+=Restriction | hints+=Hint)*
	name=ID ((':' | 'with' | 'extends') (supertypes+=TypeDeclarationReference))*
	('{' fields+=Field* '}')?;

Field:
	comment=ML_COMMENT? (restrictions+=Restriction | hints+=Hint)*
	fieldcontent=Fieldcontent ';';

Fieldcontent:
	Constant | Data;

Constant:
	constantName='const' fieldtype=Fieldtype name=ID '=' value=(LongArgument | HEXINT);

Data:
	(isAuto?='auto')? fieldtype=Fieldtype name=ID;

Fieldtype:
	Maptype | Settype | Listtype | Arraytype | Basetype;

Maptype:
	'map' '<' basetypes+=Basetype (',' basetypes+=Basetype)+ '>';

Settype:
	'set' '<' basetype=Basetype '>';

Listtype:
	'list' '<' basetype=Basetype '>';

Arraytype:
	basetype=Basetype ('[' (length=(LongArgument | HEXINT))? ']');

Basetype:
	DeclarationReference | BuiltInType;

BuiltInType:
	Integertype | Floattype | Stringtype | Annotationtype | Booleantype;

Integertype:
	type=Integer;

enum Integer:
	I8='i8' | I16='i16' | I32='i32' | I64='i64' | V64='v64';

Floattype:
	type=Float;

enum Float:
	F32='f32' | F64='f64';

Stringtype:
	type='string';

Annotationtype:
	type='annotation';

Booleantype:
	type='bool';

Restriction:
	'@' restrictionName=ID
	('(' (restrictionArguments+=RestrictionArgument (',' restrictionArguments+=RestrictionArgument)*)? ')')?;

RestrictionArgument:
	(valueDouble=DoubleArgument | valueLong=(LongArgument | HEXINT) | valueString=STRING |
	valueType=DeclarationReference (('.' | '::') enumInstance = ID)?);

Hint:
	'!' hintName=ID
	('(' (hintArguments+=HintArgument (',' hintArguments+=HintArgument)*)? ')')?;

HintArgument:
	(valueDouble=DoubleArgument | valueLong=(LongArgument | HEXINT) | valueString=STRING | valueIdentifier=ID);

LongArgument returns ecore::ELongObject:
	LONG;

DoubleArgument returns ecore::EDoubleObject:
	DOUBLE;

terminal HEADCOMMENT:
	'#' !('\r' | '\n')* '\r'? '\n';

terminal ID:
	('a'..'z' | 'A'..'Z' | '_' | '\u007f'..'\uffff') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9' | '\u007f'..'\uffff')*;

terminal HEXINT returns ecore::ELongObject:
	'-'? '0x' (DIGIT | ('a'..'f') | ('A'..'F'))*;

terminal LONG returns ecore::ELong:
	'-'? DIGIT+;

terminal DOUBLE returns ecore::EDouble:
	((LONG EXPONENT) | (LONG? '.' DIGIT* EXPONENT?)) ('f' | 'F' | 'd' | 'D')?;

terminal fragment DIGIT:
	'0'..'9';

terminal fragment EXPONENT:
	('e' | 'E') ('+' | '-')? DIGIT+;

terminal STRING:
	'"'->'"';

terminal ML_COMMENT:
	'/*'->'*/';

terminal WHITESPACE:
	(' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
	.;